---
title: "Untitled"
output: html_document
date: "2025-03-10"
---

```{r setup, include=FALSE}
library(DESeq2)
library(limma)
library(edgeR)
library(tximport)
library(dplyr)
library(readxl)
library(openxlsx)
library(readr)
library(pheatmap)
library(ggplot2)
library(ggrepel)
library(circlize) 
library(ComplexHeatmap)
library(cowplot)
library(clusterProfiler)
library(org.Mm.eg.db) ##加载小鼠
library(org.Hs.eg.db) ##加载人类
library(tidyverse)
library(reshape2)
library(fgsea)
library(msigdbr)
library(msigdbdf)
library(gridExtra)
library(umap)
library(WGCNA)
library(STRINGdb)
library(igraph)
library(ggraph)
```

## 精简列名
```{r}
GSE233242 <- read.delim("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242.tsv", comment.char="#")
expression_matrix <- GSE233242[, grepl("^Normal|^LuminalA", names(GSE233242))]
row.names(expression_matrix) <- GSE233242$Geneid
# 精简列名：删除 "_SRR" 及其后的内容
colnames(expression_matrix) <- sub("_SRR.*", "", colnames(expression_matrix))
colnames(expression_matrix) <- sub("_ASRR.*", "", colnames(expression_matrix))
expression_matrix$LuminalA42_CD44_reads.bam <- NULL

# 查看以 "Normal" 开头的列有几列
sum(startsWith(colnames(expression_matrix), "Normal"))
sum(startsWith(colnames(expression_matrix), "LuminalA"))
```
## DESeq2
```{r}
# 创建分组信息数据框
coldata <- data.frame(condition = c(rep("LuminalA", sum(startsWith(colnames(expression_matrix), "LuminalA"))), 
                                    rep("Normal", sum(startsWith(colnames(expression_matrix), "Normal")))))
# 创建DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = expression_matrix, colData = coldata, design = ~ condition)
dds <- estimateSizeFactors(dds)
normalized_counts <- counts(dds, normalized=TRUE)

write.csv(normalized_counts, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_normalized.csv")
# 运行差异分析
dds <- DESeq(dds)
# 输出结果
#注意，需将 treat 在前，control 在后，意为 treat 相较于 control 中哪些基因上调/下调
BC_deseq <- results(dds, contrast = c('condition', 'LuminalA', 'Normal'))
deseq_result <- as.data.frame(BC_deseq)
write.csv(deseq_result, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_deseq.csv")
```
## 转基因名和去重
```{r}
# 去掉baseMean为0的行
deseq_result <- deseq_result[deseq_result$baseMean != 0, ]

library(org.Mm.eg.db)
library(org.Hs.eg.db)

# 利用org.Hs.eg.db转换ENSEMBL->SYMBOL
X <- row.names(deseq_result)
deseq_result$ENSEMBL <- row.names(deseq_result)
Y <- select(org.Hs.eg.db,
                 keys = X,
                 columns = c('SYMBOL'),
                 keytype = "ENSEMBL")
deseq_result <- merge(deseq_result, Y, by.x = "ENSEMBL", by.y = "ENSEMBL", all.x = T)
Y[duplicated(Y$SYMBOL) | duplicated(Y$SYMBOL, fromLast = TRUE), ]
write.csv(deseq_result, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_deseq.csv")

```
## 计算TPM和limma
```{r}
# 计算TPM
len <- GSE233242$Length/1000
rpk_matrix <- expression_matrix / len
tpm_matrix <- t(t(rpk_matrix)/colSums(rpk_matrix) * 1000000)
write.csv(tpm_matrix, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_tpm.csv")

# 构建样本分组信息coldata
coldata <- c(rep("LuminalA", sum(startsWith(colnames(expression_matrix), "LuminalA"))),
             rep("Normal",sum(startsWith(colnames(expression_matrix), "Normal")))) %>% factor(., ordered = F)
coldata <- model.matrix(~factor(coldata)+0)
colnames(coldata) <- c("LuminalA", "Normal")
# 数据与coldata进行匹配
df.fit <- lmFit(tpm_matrix, coldata)
# 开始差异比较，记得把实验组写前面，对照组写后面
df.matrix <- makeContrasts(LuminalA - Normal , levels = coldata)
fit <- contrasts.fit(df.fit, df.matrix)
fit <- eBayes(fit)
tempOutput <- topTable(fit,n = Inf, adjust = "fdr")
tempOutput$Geneid <- row.names(tempOutput)
tpm <- as.data.frame(tpm_matrix)
tpm$Geneid <- row.names(tpm)
write.csv(tempOutput, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_limma.csv")
```
## 归一化和limma
```{r}
# 创建 DGEList 对象
dge <- DGEList(counts = expression_matrix)
# 这里我们使用上面提到的 filterByExpr() 进行自动过滤，去除低表达基因
# keep <- filterByExpr(dge)
# dge <- dge[keep, , keep.lib.sizes = FALSE]
# 归一化，得到的归一化系数被用作文库大小的缩放系数
dge <- calcNormFactors(dge)
# 使用 voom 方法进行标准化
v <- voom(dge, coldata, plot = TRUE, normalize = "quantile")
# 数据与coldata进行匹配
df.fit_2 <- lmFit(v, coldata)
# 开始差异比较，记得把实验组写前面，对照组写后面
df.matrix_2 <- makeContrasts(LuminalA - Normal , levels = coldata)
fit_2 <- contrasts.fit(df.fit_2, df.matrix_2)
fit_2 <- eBayes(fit_2)
tempOutput <- topTable(fit_2,n = Inf, adjust = "fdr")
write.csv(tempOutput, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_limma_2.csv")

df_v <- as.data.frame(v)
df_v$Geneid <- row.names(df_v)
```
## edgeR
```{r}
# 创建分组信息数据框
coldata <- c(rep("LuminalA", sum(startsWith(colnames(expression_matrix), "LuminalA"))), 
             rep("Normal", sum(startsWith(colnames(expression_matrix), "Normal"))))

# 构建 DGEList 对象
dgelist <- DGEList(counts = expression_matrix, group = coldata)

#过滤 low count 数据，例如 CPM 标准化（推荐）
# keep <- rowSums(cpm(dgelist) > 1 ) >= 2
# dgelist <- dgelist[keep, , keep.lib.sizes = FALSE]

# 标准化
dgelist_norm <- calcNormFactors(dgelist, method = 'TMM')

#差异表达基因分析
#首先根据分组信息构建试验设计矩阵，分组信息中一定要是对照组在前，处理组在后
design <- model.matrix(~coldata)

#（1）估算基因表达值的离散度
dge <- estimateDisp(dgelist_norm, design, robust = TRUE)

#（2）模型拟合，edgeR 提供了多种拟合算法
#负二项广义对数线性模型
fit <- glmFit(dge, design, robust = TRUE)
lrt <- topTags(glmLRT(fit), n = nrow(dgelist$counts))

write.csv(lrt, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_edgeR.csv")

#拟似然负二项广义对数线性模型
fit <- glmQLFit(dge, design, robust = TRUE)
lrt <- topTags(glmQLFTest(fit), n = nrow(dgelist$counts))

write.csv(lrt, "D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_edgeR_2.csv")
```
## 火山图
```{r}
GSE233242_normal_luminalA_deseq <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_deseq.csv")

DEG <- GSE233242_normal_luminalA_deseq[,-1]

#加载包
library(ggplot2)
library(ggrepel)
# 数据预处理
DEG$`-log(P)` <- -log10(DEG$padj)
DEG$threshold <- factor(ifelse(DEG$padj < 0.05 & abs(DEG$log2FoldChange) >= 1, 
                              ifelse(DEG$log2FoldChange >= 1, "Up", "Down"), 
                              "Not significant"))
DEG <- DEG[order(-abs(DEG$`-log(P)`) - DEG$log2FoldChange), ]  # 按logFC和-log10(P value)排序
top20_genes <- head(DEG, 20)  # 取前20个基因
#先用ggplot函数画好基础图
p <- ggplot(DEG, aes(x = log2FoldChange, y = `-log(P)`, color = threshold)) +
  geom_point(size = 2) +
  scale_color_manual(values = c("Up" = "red", "Down" = "blue", "Not significant" = "grey")) +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "black") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "black") +
  labs(x = "logFC", y = "-log(P value)", color = "Expression") +
  theme_minimal() +
  theme(legend.position = "bottom",panel.border = element_rect(colour = "black", fill = NA, linewidth = 1))
#然后用额外的函数加上个性化内容
  #标记显著基因
p + geom_text_repel(data = subset(DEG, threshold != "Not significant"), 
                    aes(label = SYMBOL), size = 3, box.padding = 0.5)
  #标记前20个基因
p + geom_text_repel(data = top20_genes, aes(label = SYMBOL), size = 3, box.padding = 0.5, max.overlaps = 20, color = "black")
  #标记指定基因
FGFRs <- c("FGFR1","FGFR2","FGFR3","FGFR4")
selected_genes <- DEG %>% filter(SYMBOL %in% FGFRs)
p + geom_text_repel(data = selected_genes, aes(label = SYMBOL), size = 3, box.padding = 0.5, max.overlaps = 20, color = "black")



```
## complexheatmap
```{r}
expression_df <- GSE233242[,-c(2:6)]
# 精简列名：删除 "_SRR" 及其后的内容
colnames(expression_df) <- sub("_SRR.*", "", colnames(expression_df))
colnames(expression_df) <- sub("_ASRR.*", "", colnames(expression_df))
expression_df$LuminalA42_CD44_reads.bam <- NULL
group = c(rep("HER", sum(startsWith(colnames(expression_df), "HER"))), 
          rep("LuminalA", sum(startsWith(colnames(expression_df), "LuminalA"))), 
          rep("LuminalB", sum(startsWith(colnames(expression_df), "LuminalB"))), 
          rep("Normal", sum(startsWith(colnames(expression_df), "Normal"))), 
          rep("TNBC", sum(startsWith(colnames(expression_df), "TNBC"))))
coldata <- data.frame(group)
row.names(expression_df) <- expression_df$Geneid
expression_df <- expression_df[,-1]

# 创建DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = expression_df, colData = coldata, design = ~ group)
dds <- estimateSizeFactors(dds)
normalized_counts <- counts(dds, normalized=TRUE)
normalized_counts <- as.data.frame(normalized_counts)
normalized_counts$ENSEMBL <- row.names(normalized_counts)

DEG_counts <- merge(DEG, normalized_counts, by.x = "ENSEMBL", by.y = "ENSEMBL", all.x = T)
DEG_counts$SYMBOL <- ifelse(is.na(DEG_counts$SYMBOL), DEG_counts$ENSEMBL, DEG_counts$SYMBOL)

# 加载软件包
library(circlize) 
library(ComplexHeatmap)

# 挑出有显著性差异的基因
DEG_counts_sig <- DEG_counts %>% filter(DEG_counts$threshold != "Not significant")

# 准备用于绘制热图的矩阵
heatmap_use <- DEG_counts_sig[,11:96]

# 将重复的Symbol重命名
DEG_counts_sig <- DEG_counts_sig %>%
  mutate(SYMBOL = make.unique(as.character(SYMBOL), sep = "_"))

# 将Symbol赋给热图矩阵的行名
row.names(heatmap_use) <- DEG_counts_sig$SYMBOL

# 构建列名注释
annotation_col <- data.frame(group = group)
row.names(annotation_col) <- colnames(DEG_counts_sig[11:96])

# 定义列注释颜色
group_colors <- c(
  HER = "#1F77B4", 
  LuminalA = "#FF7F0E", 
  LuminalB = "#2CA02C", 
  Normal = "#D62728", 
  TNBC = "#9467BD"
)

# 创建列注释
column_ha <- HeatmapAnnotation(
  group = group,
  col = list(group = group_colors),
  annotation_legend_param = list(
    group = list(
      title = "Group",  # 图例标题
      labels = names(group_colors)  # 图例标签
    )
  )
)

# 标记感兴趣的基因
interest_genes <- c("CD22", "CD6", "CD177")

# 创建行注释（标记感兴趣的基因）
row_annotation <- rowAnnotation(
  Interest = ifelse(rownames(heatmap_use) %in% interest_genes, "Yes", "No")
)
ha <- rowAnnotation(foo = anno_mark(at = which(rownames(heatmap_use) %in% interest_genes), 
                                     labels = interest_genes))

# 对行（基因表达量）进行Z-score标准化
heatmap_use <- t(scale(t(heatmap_use)))
p <- Heatmap(heatmap_use, 
        name = "Expression",
        top_annotation = column_ha,  # 添加列注释
        col = colorRamp2(c(-4, 0, 4), c("blue", "white", "red")),  # 定义热图颜色
       # row_names_side = "left",  # 行名显示在左侧
        show_column_names = FALSE, 
        show_row_names = FALSE, # 隐藏列名
        right_annotation = ha,
        cluster_columns = F,
        use_raster = F)
```
## pheatmap
```{r}
library(pheatmap)
# 提取指定列
heatmap_2 <- heatmap_use[c("CD22", "CD6", "CD177", "CD5","CD81","CD2","CD80", "CD36"),
                         c("LuminalA10", "LuminalA11", "LuminalA12", "LuminalA15", 
                            "Normal10", "Normal11", "Normal12", "Normal13")]

pheatmap(
  heatmap_2,
  scale = "row",
  cluster_cols = FALSE,
  gaps_col = c(4),
  border_color = "black"
)
```

```{r}
# 打开PDF设备
pdf("./heatmap_plot_deseq2.pdf", width = 8, height = 6)

# 绘制热图
draw(p)  # p是Heatmap对象

# 关闭PDF设备
dev.off()
```

```{r}
GSE233242_normal_luminalA_deseq <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_deseq.csv")
GSE233242_normal_luminalA_normalized <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_normalized.csv")
GSE233242_normal_luminalA_deseq <- GSE233242_normal_luminalA_deseq[,-1]
new <- merge(GSE233242_normal_luminalA_deseq, GSE233242_normal_luminalA_normalized, 
             by.x = "ENSEMBL", by.y = "X", all.x = T)
new <- new[!is.na(new$SYMBOL), ]
new <- new[,-c(1:7)]
new_cleaned <- new %>%
  group_by(SYMBOL) %>%  # 按基因名分组
  summarise(across(everything(), mean, na.rm = TRUE))  # 对每一列取平均值
duplicate_genes <- new %>%
  group_by(SYMBOL) %>%
  filter(n() > 1) %>%
  pull(SYMBOL) %>%
  unique()
write.table(new_cleaned, file = "./GSEA_USE.txt", sep = "\t", row.names = FALSE, quote = FALSE)
```

```{r}
# 导入数据
GSE233242_normal_luminalA_deseq <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_deseq.csv")
DEG <- GSE233242_normal_luminalA_deseq[,-1]

# 数据预处理
DEG$`-log(P)` <- -log10(DEG$padj)
DEG$threshold <- factor(ifelse(DEG$padj < 0.05 & abs(DEG$log2FoldChange) >= 1, 
                              ifelse(DEG$log2FoldChange >= 1, "Up", "Down"), 
                              "Not significant"))
# 提取LuminalA组上调或下调的行
DEG_up <- subset(DEG, threshold == "Up")
DEG_Down <- subset(DEG, threshold == "Down")

# 载入包
library(clusterProfiler)

# 提取基因名
up_list <- DEG_up$ENSEMBL
Down_list <- DEG_Down$ENSEMBL
# 分别对BP, CC和MF进行富集
up_CC <- enrichGO(gene          = up_list,
                   #universe     = row.names(dge.celltype),
                   OrgDb         = 'org.Hs.eg.db',
                   keyType       = 'ENSEMBL',
                   ont           = "CC",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.05,
                   qvalueCutoff  = 0.05)
up_cc <- data.frame(up_CC)
write.csv(up_cc,'enrichGO_cc_up.csv') 
up_MF <- enrichGO(gene          = up_list,
                   #universe     = row.names(dge.celltype),
                   OrgDb         = 'org.Hs.eg.db',
                   keyType       = 'ENSEMBL',
                   ont           = "MF",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.05,
                   qvalueCutoff  = 0.05)
up_mf <- data.frame(up_MF)
write.csv(up_mf,'enrichGO_mf_up.csv') 
up_BP <- enrichGO(gene          = up_list,
                   #universe     = row.names(dge.celltype),
                   OrgDb         = 'org.Hs.eg.db',
                   keyType       = 'ENSEMBL',
                   ont           = "BP",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.05,
                   qvalueCutoff  = 0.05) 
up_bp <- data.frame(up_BP)
write.csv(up_bp,'enrichGO_bp_up.csv')

# 分别对BP, CC和MF进行富集
Down_CC <- enrichGO(gene          = Down_list,
                   #universe     = row.names(dge.celltype),
                   OrgDb         = 'org.Hs.eg.db',
                   keyType       = 'ENSEMBL',
                   ont           = "CC",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.05,
                   qvalueCutoff  = 0.05)
Down_cc <- data.frame(Down_CC)
write.csv(Down_cc,'enrichGO_cc_Down.csv') 
Down_MF <- enrichGO(gene          = Down_list,
                   #universe     = row.names(dge.celltype),
                   OrgDb         = 'org.Hs.eg.db',
                   keyType       = 'ENSEMBL',
                   ont           = "MF",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.05,
                   qvalueCutoff  = 0.05)
Down_mf <- data.frame(Down_MF)
write.csv(Down_mf,'enrichGO_mf_Down.csv') 
Down_BP <- enrichGO(gene          = Down_list,
                   #universe     = row.names(dge.celltype),
                   OrgDb         = 'org.Hs.eg.db',
                   keyType       = 'ENSEMBL',
                   ont           = "BP",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.05,
                   qvalueCutoff  = 0.05) 
Down_bp <- data.frame(Down_BP)
write.csv(Down_bp,'enrichGO_bp_Down.csv')
# 可视化
bar_up_BP <- barplot(up_BP,showCategory = 10) + ggtitle("barplot for Biological process")
bar_down_BP <- barplot(Down_BP,showCategory = 10) + ggtitle("barplot for Biological process")
barplot(up_CC,showCategory = 10) + ggtitle("barplot for Cellular component")
barplot(up_MF,showCategory = 10) + ggtitle("barplot for Molecular function")
barplot(Down_CC,showCategory = 10) + ggtitle("barplot for Cellular component")
barplot(Down_MF,showCategory = 10) + ggtitle("barplot for Molecular function")
barplot_BP <- bar_up_BP + bar_down_BP
ggsave('enrichGO_barplot_BP.pdf', barplot_BP, width = 20,height = 10)
dot_up_BP <- dotplot(up_BP,showCategory = 10) + ggtitle("barplot for Biological process")
dot_down_BP <- dotplot(Down_BP,showCategory = 10) + ggtitle("barplot for Biological process")
dotplot_BP <- dot_up_BP + dot_down_BP
ggsave('enrichGO_dotplot_BP.pdf', dotplot_BP, width = 20,height = 10)


```

```{r}
up_ENTREZID <- bitr(up_list, fromType="ENSEMBL",
                 toType="ENTREZID", OrgDb='org.Hs.eg.db')
up_ENTREZID <- pull(up_ENTREZID,ENTREZID)               
up_kegg <- enrichKEGG(gene = up_ENTREZID, organism = 'hsa',pvalueCutoff=0.05)
up_KEGG <- data.frame(up_kegg)
write.csv(up_KEGG,'enrichKEGG_up.csv')

Down_ENTREZID <- bitr(Down_list, fromType="ENSEMBL",
                 toType="ENTREZID", OrgDb='org.Hs.eg.db')
Down_ENTREZID <- pull(Down_ENTREZID,ENTREZID)               
Down_kegg <- enrichKEGG(gene = Down_ENTREZID, organism = 'hsa',pvalueCutoff=0.05)
Down_KEGG <- data.frame(Down_kegg)
write.csv(Down_KEGG,'enrichKEGG_Down.csv')

p1_up <- barplot(up_kegg, showCategory=20)
p1_down <- barplot(Down_kegg, showCategory=20)
p2_up <- dotplot(up_kegg, showCategory=20)
p2_down <- dotplot(Down_kegg, showCategory=20)
barplot_kegg = p1_up+p1_down
dotplot_kegg = p2_up+p2_down
ggsave("enrichKEGG_bar.pdf", plot = barplot_kegg, width = 20, height = 10)
ggsave("enrichKEGG_dot.pdf", plot = dotplot_kegg, width = 20, height = 10)

```

```{r}
# 排序数据，按 p.adjust 从小到大排序
up_bp <- up_bp[order(up_bp$p.adjust), ]
up_bp_top20 <- up_bp[1 : 20,]

# 计算Enrichment Factor
up_bp_top20 <- up_bp_top20 %>%
  # 将 Ratio_in_study 转换为数值比例
  mutate(GeneRatio = sapply(strsplit(GeneRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))) %>%
  # 将 Ratio_in_pop 转换为数值比例
  mutate(BgRatio = sapply(strsplit(BgRatio, "/"), function(x) as.numeric(x[1]) / as.numeric(x[2]))) %>%
  # 计算富集因子
  mutate(FoldEnrichment = GeneRatio / BgRatio) %>%
  # 按 P_value 排序并选择前20个最显著的通路
  arrange(p.adjust) %>%
  head(20)

# 绘制 Barplot
ggplot(up_bp_top20, aes(x = FoldEnrichment, y = reorder(Description, -p.adjust), fill = -log10(p.adjust))) +
  geom_bar(stat = "identity", color = "black") +
  scale_fill_gradient(low = "purple", high = "gold" ) +  # 颜色从紫色到金色
  labs(
    x = "Enrichment factor",
    y = "GO Term Description",
    title = "GO Enrichment Analysis (BP)",
    fill = "-log10(Adjusted p-value)"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        panel.border = element_rect(color = "black", fill = NA, size = 0.6))# 设置边框颜色为黑色，宽度为1

# 绘制气泡图
ggplot(up_bp_top20, aes(x = FoldEnrichment, y = reorder(Description, -p.adjust), size = Count, fill = -log10(p.adjust))) +
  geom_point(shape = 21, color = "black", alpha = 1, stroke = 0.7) +  # shape = 21 是带边框的点，color 设置边框颜色, alpha是透明度，stroke控制边框的粗细
  scale_fill_gradient(low = "purple", high = "gold") +  # 填充颜色从紫色到金色
  scale_size(range = c(3, 10)) +  # 调整点的大小范围，增大上限值使点更大
  labs(
    x = "Enrichment Factor",
    y = "GO Term Description",
    title = "GO Enrichment Analysis (BP)",
    size = "Count",
    fill = "-log10(Adjusted p-value)"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        panel.border = element_rect(color = "black", fill = NA, size = 0.6)) # 设置边框颜色为黑色，宽度为1
```

```{r}
# 导入数据
normalized_count <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_normalized.csv")
# 把ENSEMBL ID转成SYMBOL
Y <- bitr(normalized_count$X, fromType="ENSEMBL", toType="SYMBOL", OrgDb='org.Hs.eg.db')
GSEA_use <- merge(normalized_count, Y, by.x = "X", by.y = "ENSEMBL", all.y = T)
# 检查一下SYMBOL有没有重复
duplicate_genes <- GSEA_use %>%
  group_by(SYMBOL) %>%
  filter(n() > 1) %>%
  pull(SYMBOL) %>%
  unique()
# 去NA和取平均去重
GSEA_use <- GSEA_use[!is.na(GSEA_use$SYMBOL), ]
GSEA_use <- GSEA_use %>%
  group_by(SYMBOL) %>%  # 按基因名分组
  summarise(across(everything(), \(x) mean(x, na.rm = TRUE)))  # 对每一列取平均值
GSEA_use <- GSEA_use[,-2]
# 重写成tab分隔符的文本文件
write.table(GSEA_use, file = "./GSEA_USE.txt", sep = "\t", row.names = FALSE, quote = FALSE)


```
## fgsea
```{r}
DEG <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_deg.csv")
DEG <- DEG[,-1]
library(fgsea)
library(tidyverse)
library(org.Hs.eg.db)
library(msigdbr)
library(msigdbdf)

# 去重
DEG_filtered <- DEG[!is.na(DEG$SYMBOL), ]
DEG_fgsea <- DEG_filtered %>%
  group_by(SYMBOL) %>%  # 按基因名分组
  summarise(across(everything(), \(x) mean(x, na.rm = TRUE)))  # 对每一列取平均值
duplicate_genes <- DEG_fgsea %>%
  group_by(SYMBOL) %>%
  filter(n() > 1) %>%
  pull(SYMBOL) %>%
  unique()

DEG_fgsea <- DEG_fgsea %>%
  dplyr::select(!c(ENSEMBL, threshold))
DEG_fgsea$threshold <- factor(ifelse(DEG_fgsea$padj < 0.05 & abs(DEG_fgsea$log2FoldChange) >= 1, 
                              ifelse(DEG_fgsea$log2FoldChange >= 1, "Up", "Down"), 
                              "Not significant"))

# fgsea需要接收foldchange，但它不能为list类型，只能为向量。且每个foldchange的行名为ENTREZID，然后从大到小排序
rank_df<-DEG_fgsea$log2FoldChange
names(rank_df)<-DEG_fgsea$SYMBOL
rank_df<-sort(rank_df,decreasing = TRUE)
View(rank_df)
###### pathway文件准备
# fgsea需要接收pathway文件，格式为list，列名为各通路，元素为参与该通路的所有ENTREZID，以character格式存在，这些通路和ENTREZID可以从MSigDB找到。
msigdb.hs = msigdbr(species = "Homo sapiens",category = "C5",subcategory = "BP")  
# 这个数据库的格式还不能直接用，需要调整为最后的pathway形式
msigdb.hs_index<-msigdb.hs[!duplicated(msigdb.hs[,9]),] #提取gs_name作为索引
pathway<-list() # 初始化pathway
for(i in 1:nrow(msigdb.hs_index)){
  pathway_name<-c(msigdb.hs_index[i,9])
  path_list<-subset(msigdb.hs,msigdb.hs$gs_name==pathway_name)
  e_id_list<-as.character(path_list$gene_symbol)
  pathway[[i]]<-e_id_list
} #循环将entrez_gene与gs_name相匹配
names(pathway)<-msigdb.hs_index$gs_name
# 后续其他数据分析可以直接导入使用，不需要再跑一次
dput(pathway, file = "GO_BP_pathway_SYMBOL.txt")
# 读取文件
pathway <- dget("GO_BP_pathway_SYMBOL.txt")

# GESA分析
fgseaRes <- fgsea(pathways = pathway, 
                  stats = rank_df,
                  minSize=15,
                  maxSize=500)

df_fgseaRes = data.frame(lapply(fgseaRes, as.character), stringsAsFactors=FALSE)
write.table(df_fgseaRes,file = "fgseaRes.txt",sep="\t",quote = FALSE,row.names = FALSE)
```
## fgsea可视化
```{r}
library(gridExtra)
library(ggplot2)

# 按 padj 列从小到大排序
fgseaRes <- fgseaRes[order(fgseaRes$padj), ]
# plot the most significantly enriched pathway
plotEnrichment(pathway[[fgseaRes[2, ]$pathway]],
               rank_df) + labs(title=fgseaRes[2, ]$pathway)

# 生成示例图形列表
plot_list <- lapply(1:10, function(i) {
  plotEnrichment(pathway[[fgseaRes[i, ]$pathway]],
               rank_df) + 
    labs(title=fgseaRes[i, ]$pathway)
})

gsea_plots <- grid.arrange(grobs = plot_list, nrow = 2, ncol = 5)
ggsave(
  filename = "gsea_plots.pdf",
  plot = gsea_plots,
  width = 30,   
  height = 12,  
  limitsize = FALSE  # 允许调整大小
)

# 上调/下调前15个pathway
topPathwaysUp <- fgseaRes[ES > 0][head(order(pval), n=15), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(pval), n=15), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
gsea_table <- plotGseaTable(pathway[topPathways], rank_df, fgseaRes, 
              gseaParam = 0.5)
ggsave(
  filename = "gsea_table.pdf",
  plot = gsea_table,
  width = 15,   
  height = 15,  
  limitsize = FALSE  # 允许调整大小
)

```


```{r}
# 统计leading edge的数量
View(fgseaRes$leadingEdge)
fgseaRes$leadingCount <- lengths(fgseaRes$leadingEdge)
fgseaRes_up <- fgseaRes[ES > 0]
fgseaRes_down <- fgseaRes[ES < 0]
up_top20 <- fgseaRes_up[1:20,]
down_top20 <- fgseaRes_down[1:20,]
# 绘制气泡图
up_dotplot <- ggplot(up_top20, aes(x = NES, y = reorder(pathway, -padj), size = leadingCount, fill = -log10(padj))) +
  geom_point(shape = 21, color = "black", alpha = 1, stroke = 0.7) +  # shape = 21 是带边框的点，color 设置边框颜色, alpha是透明度，stroke控制边框的粗细
  scale_fill_gradient(low = "purple", high = "gold") +  # 填充颜色从紫色到金色
  scale_size(range = c(3, 10)) +  # 调整点的大小范围，增大上限值使点更大
  labs(
    x = "Normalized Enrichment Score",
    y = "Pathway Description",
    title = "GSEA Up-regulated (BP)",
    size = "Count",
    fill = "-log10(Adjusted p-value)"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        panel.border = element_rect(color = "black", fill = NA, size = 0.6)) # 设置边框颜色为黑色，宽度为1

down_dotplot <- ggplot(down_top20, aes(x = NES, y = reorder(pathway, -padj), size = leadingCount, fill = -log10(padj))) +
  geom_point(shape = 21, color = "black", alpha = 1, stroke = 0.7) +  # shape = 21 是带边框的点，color 设置边框颜色, alpha是透明度，stroke控制边框的粗细
  scale_fill_gradient(low = "purple", high = "gold") +  # 填充颜色从紫色到金色
  scale_size(range = c(3, 10)) +  # 调整点的大小范围，增大上限值使点更大
  labs(
    x = "Normalized Enrichment Score",
    y = "Pathway Description",
    title = "GSEA Down-regulated (BP)",
    size = "Count",
    fill = "-log10(Adjusted p-value)"
  ) +
  theme_minimal() +
  theme(axis.text.y = element_text(size = 10),
        panel.border = element_rect(color = "black", fill = NA, size = 0.6)) # 设置边框颜色为黑色，宽度为1
gsea_dotplot <- up_dotplot/down_dotplot
ggsave(
  filename = "gsea_dotplot.pdf",
  plot = gsea_dotplot,
  width = 15,   
  height = 20,  
  limitsize = FALSE  # 允许调整大小
)

```
# DESeq2自带的PCA
```{r}
GSE233242 <- read.delim("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242.tsv", comment.char="#")
expression_df <- GSE233242[,-c(2:6)]
# 精简列名：删除 "_SRR" 及其后的内容
colnames(expression_df) <- sub("_SRR.*", "", colnames(expression_df))
colnames(expression_df) <- sub("_ASRR.*", "", colnames(expression_df))
expression_df$LuminalA42_CD44_reads.bam <- NULL
group = c(rep("HER", sum(startsWith(colnames(expression_df), "HER"))), 
          rep("LuminalA", sum(startsWith(colnames(expression_df), "LuminalA"))), 
          rep("LuminalB", sum(startsWith(colnames(expression_df), "LuminalB"))), 
          rep("Normal", sum(startsWith(colnames(expression_df), "Normal"))), 
          rep("TNBC", sum(startsWith(colnames(expression_df), "TNBC"))))
coldata <- data.frame(group)
row.names(expression_df) <- expression_df$Geneid
expression_df <- expression_df[,-1]

# 创建DESeqDataSet
dds <- DESeqDataSetFromMatrix(countData = expression_df, colData = coldata, design = ~ group)
dds <- estimateSizeFactors(dds)
rld <- vst(dds)   #DEseq2自己的方法标准化数据`
normalized_counts <- assay(rld)
plotPCA(rld, intgroup=c('group'), returnData = F)

# sd1 <- sd(pca$PC1, na.rm = FALSE)
# sd2 <- sd(pca$PC2, na.rm = FALSE)
# sd <- c(sd1,sd2)
# variance_contributions <- round(sd^2 / sum(sd^2) * 100, 2)
# xlab1 <- paste0("PC1(",variance_contributions[1],"%)")
# ylab1 <- paste0("PC2(",variance_contributions[2],"%)")
# 
# pca_plot <- ggplot(data = pca,aes(x = PC1,y = PC2,color = pca$group))+
#   stat_ellipse(aes(fill = pca$group),
#                type = "norm",geom = "polygon",alpha = 0.25,color = NA)+ # 添加置信椭圆
#   geom_point(size = 3.5)+
#   labs(x = xlab1,y = ylab1,color = "group",title = "PCA Plot for GSE233242")+
#   guides(fill = "none")+
#   theme_bw()+
#   #scale_fill_manual(values = c("#7895C1","#E3625D","#F5EBAE","#A8CBDF","#8074C8"))+
#   #scale_colour_manual(values = c("#7895C1","#E3625D","#F5EBAE","#A8CBDF","#8074C8"))+
#   theme(plot.title = element_text(hjust = 0.5,size = 15),
#         axis.text = element_text(size = 11),axis.title = element_text(size = 13),
#         legend.text = element_text(size = 11),legend.title = element_text(size = 13),
#         plot.margin = unit(c(0.4,0.4,0.4,0.4),'cm'))
# ggsave(
#   filename = "pca_plot.pdf",
#   plot = pca_plot,
#   width = 8,   
#   height = 6,  
#   limitsize = FALSE
#   )
```
# prcomp
```{r}
# 转置数据框
normalized_counts_t <- t(normalized_counts)
# 进行PCA分析
pca_res <- prcomp(normalized_counts_t, scale = F)
# 计算方差贡献率
variance_contributions <- pca_res$sdev^2 / sum(pca_res$sdev^2) * 100
xlab1 <- paste0("PC1(",round(variance_contributions[1],2),"%)")
ylab1 <- paste0("PC2(",round(variance_contributions[2],2),"%)")
# 可视化PCA
pca_plot <- ggplot(data = pca_res$x[,1:2],aes(x = PC1,y = PC2,color = coldata$group))+
  stat_ellipse(aes(fill = coldata$group),
               type = "norm",geom = "polygon",alpha = 0.25,color = NA)+ # 添加置信椭圆
  geom_point(size = 3.5)+
  labs(x = xlab1,y = ylab1,color = "group",title = "PCA Plot for GSE233242")+
  guides(fill = "none")+
  theme_bw()+
  #scale_fill_manual(values = c("#7895C1","#E3625D","#F5EBAE","#A8CBDF","#8074C8"))+
  #scale_colour_manual(values = c("#7895C1","#E3625D","#F5EBAE","#A8CBDF","#8074C8"))+
  theme(plot.title = element_text(hjust = 0.5,size = 15),
        axis.text = element_text(size = 11),axis.title = element_text(size = 13),
        legend.text = element_text(size = 11),legend.title = element_text(size = 13),
        plot.margin = unit(c(0.4,0.4,0.4,0.4),'cm'))
ggsave(
  filename = "pca_plot.pdf",
  plot = pca_plot,
  width = 8,   
  height = 6,  
  limitsize = FALSE
  )

# 3D可视化PCA
color = color = c(rep('#F8766D',sum(startsWith(coldata$group, "HER"))),
                  rep('#A3A500',sum(startsWith(coldata$group, "LuminalA"))),
                  rep('#00BF7D',sum(startsWith(coldata$group, "LuminalB"))),
                  rep('#00B0F6',sum(startsWith(coldata$group, "Normal"))),
                  rep('#E76BF3',sum(startsWith(coldata$group, "TNBC")))
                  )
pca_s3d <- scatterplot3d(
  pca_res$x[,1:3],
  color=color,
  pch = 16,angle=60,
  box=T,type="p",
lty.hide=2,lty.grid = 2)
legend(
  pca_s3d$xyz.convert(60, -40, 0),
  c('HER','LuminalA','LuminalB',"Normal","TNBC"),
  fill=c('#F8766D','#A3A500','#00BF7D',"#00B0F6","#E76BF3"),
  box.col=NA, 
  bg = "transparent" 
  )
# 选定前50个PC
pca_data <- pca_res$x[, 1:50]
# 进行UMAP降维
set.seed(123)  # 设置随机种子以保证结果可重复
umap_result <- umap(pca_data)
# 提取UMAP的二维嵌入
umap_layout <- umap_result$layout

# 假设你的分组信息存储在 group 变量中
umap_df <- data.frame(UMAP1 = umap_layout[, 1], UMAP2 = umap_layout[, 2], Group = coldata$group)
umap_plot <- ggplot(umap_df, aes(x = UMAP1, y = UMAP2, color = Group)) +
  geom_point(size = 3) +
  theme_bw() +
  labs(x = "UMAP1", y = "UMAP2", title = "UMAP on PCA")+
  theme(plot.title = element_text(hjust = 0.5,size = 15),
        axis.text = element_text(size = 11),axis.title = element_text(size = 13),
        legend.text = element_text(size = 11),legend.title = element_text(size = 13),
        plot.margin = unit(c(0.4,0.4,0.4,0.4),'cm'))
ggsave(
  filename = "umap_plot.pdf",
  plot = umap_plot,
  width = 8,   
  height = 6,  
  limitsize = FALSE
  )
```

## WGCNA
```{r}
options(stringsAsFactors = FALSE) 
enableWGCNAThreads() ## 打开多线程

GSE233242_normal_luminalA_tpm <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_tpm.csv")

datExpr0 = as.data.frame(t(GSE233242_normal_luminalA_tpm[,-1])) 
names(datExpr0) = GSE233242_normal_luminalA_tpm$X; 
rownames(datExpr0) = names(GSE233242_normal_luminalA_tpm[,-1])
# 筛选基因
gsg = goodSamplesGenes(datExpr0, verbose = 3) 
gsg$allOK 
if (!gsg$allOK) 
{ 
  # 打印将被去掉的基因
  if (sum(!gsg$goodGenes)>0) 
    printFlush(paste("Removing genes:", paste(names(datExpr0)[!gsg$goodGenes], collapse = ", "))) 
  if (sum(!gsg$goodSamples)>0) 
    printFlush(paste("Removing samples:", paste(rownames(datExpr0)[!gsg$goodSamples], collapse = ", "))) 
  # 去掉不好的基因
  datExpr0 = datExpr0[gsg$goodSamples, gsg$goodGenes] 
}
# 过滤低表达基因
mean= 0.5  # 过滤标准，标准越高基因越少，运算量越少，但丢失信息可能性越大
n=nrow(datExpr0) 
datExpr0[n+1,]=apply(datExpr0[c(1:nrow(datExpr0)),],2,mean) 
datExpr0=datExpr0[1:n,datExpr0[n+1,] > mean] 
filteredmean=t(datExpr0) 
filteredmean=data.frame(rownames(filteredmean),filteredmean) 
names(filteredmean)[1]="sample" 
head(filteredmean) 
write.table(filteredmean, file="mRNA.symbol.uniq.filter.txt", 
            row.names=F, col.names=T,quote=FALSE,sep="\t")

# 样本聚类
sampleTree = hclust(dist(datExpr0), method = "average") 
pdf(file = "1.sampleClustering.pdf", width = 15, height = 8) 
par(cex = 0.6) 
par(mar = c(0,6,6,0)) 
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 2, 
     cex.axis = 1.5, cex.main = 2) 
# 绘制cut-off红线？
# abline(h = 180, col = "red")
dev.off()

# 创建分组信息（性状）
allTraits <- data.frame(Normal = rep(NA, nrow(datExpr0)),
                       Cancer = rep(NA, nrow(datExpr0)),
                       row.names = rownames(datExpr0))

# LuminalA开头的行：Cancer=1, Normal=0
luminal_rows <- grepl("^LuminalA", rownames(allTraits))
allTraits$Cancer[luminal_rows] <- 1
allTraits$Normal[luminal_rows] <- 0

# Normal开头的行：Normal=1, Cancer=0
normal_rows <- grepl("^Normal", rownames(allTraits))
allTraits$Normal[normal_rows] <- 1
allTraits$Cancer[normal_rows] <- 0

# 匹配表达矩阵和性状信息
dataSamples = rownames(datExpr0) 
traitSamples = rownames(allTraits) 
traitRows = match(dataSamples, traitSamples) 
datTraits = allTraits[traitRows,] 
rownames(datTraits) 
collectGarbage()

traitColors <- numbers2colors(datTraits, signed = FALSE)
pdf(file="2.Sample_dendrogram_and_trait_heatmap.pdf",width=20,height=12) 
plotDendroAndColors(sampleTree, traitColors, 
                    groupLabels = names(datTraits), 
                    main = "Sample dendrogram and trait heatmap",cex.colorLabels = 1.5, cex.dendroLabels = 1, cex.rowText = 2) 
dev.off() 

# 获取最佳power值
powers = c(c(1:10), seq(from = 12, to=100, by=2))
sft = pickSoftThreshold(datExpr0, powerVector=powers, 
                        networkType="signed", verbose=5)
sft$powerEstimate # 最佳的beta值
sft$fitIndices
softPower = sft$powerEstimate

# 网络构建
adjacency = adjacency(datExpr0, power = softPower) 
TOM = TOMsimilarity(adjacency); 
dissTOM = 1-TOM 

# 层次聚类
geneTree = hclust(as.dist(dissTOM), method = "average"); 

pdf(file="3.Gene clustering on TOM-based dissimilarity.pdf",width=24,height=18) 
plot(geneTree, xlab="", sub="", main = "Gene clustering on TOM-based dissimilarity", 
     labels = FALSE, hang = 0.04) 
dev.off()

# 设定最小模块大小
minModuleSize = 10
# 动态树表示模块 
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM, 
                            deepSplit = 2, pamRespectsDendro = FALSE, 
                            minClusterSize = minModuleSize); 
table(dynamicMods) 
 
# 数字标签转颜色条块
dynamicColors = labels2colors(dynamicMods) 
table(dynamicColors) 

pdf(file="4.Dynamic Tree Cut.pdf",width=8,height=6) 
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", 
                    dendroLabels = FALSE, hang = 0.03, 
                    addGuide = TRUE, guideHang = 0.05, 
                    main = "Gene dendrogram and module colors") 
dev.off()

# 计算模块特征基因
MEList = moduleEigengenes(datExpr0, colors = dynamicColors) 
MEs = MEList$eigengenes 
# 模块特征基因相异性
MEDiss = 1-cor(MEs); 
# 聚类特征基因
METree = hclust(as.dist(MEDiss), method = "average") 
 
pdf(file="5.Clustering of module eigengenes.pdf",width=7,height=6) 
plot(METree, main = "Clustering of module eigengenes", 
     xlab = "", sub = "") 
MEDissThres = 0.4
abline(h=MEDissThres, col = "red") # 标识剪切红线
dev.off()

# 自动合并
merge = mergeCloseModules(datExpr0, dynamicColors, verbose = 3) 
# 合并模块颜色
mergedColors = merge$colors 
# 新合并模块的颜色
mergedMEs = merge$newMEs 
table(mergedColors) 

pdf(file="6.merged dynamic.pdf", width = 9, height = 6) 
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), 
                    c("Dynamic Tree Cut", "Merged dynamic"), 
                    dendroLabels = FALSE, hang = 0.03, 
                    addGuide = TRUE, guideHang = 0.05) 
dev.off()

# 为各颜色模块添加数字相关性标签
moduleColors = mergedColors 

colorOrder = c("grey", standardColors(50)) 
moduleLabels = match(moduleColors, colorOrder)-1 
MEs = mergedMEs 
 
nGenes = ncol(datExpr0) 
nSamples = nrow(datExpr0) 
moduleTraitCor = cor(MEs, datTraits, use = "p") 
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples) 
 
 
pdf(file="7.Module-trait relationships.pdf",width=10,height=10) 
 
textMatrix = paste(signif(moduleTraitCor, 2), "\n(", 
                   signif(moduleTraitPvalue, 1), ")", sep = "") 
 
dim(textMatrix) = dim(moduleTraitCor) 
par(mar = c(6, 8.5, 3, 3)) 
 
labeledHeatmap(Matrix = moduleTraitCor, 
               xLabels = names(datTraits), 
               yLabels = names(MEs), 
               ySymbols = names(MEs), 
               colorLabels = FALSE, 
               colors = greenWhiteRed(50), 
               textMatrix = textMatrix, 
               setStdMargins = FALSE, 
               cex.text = 0.5, 
               zlim = c(-1,1), 
               main = paste("Module-trait relationships")) 
dev.off()

# 模块间相关性
nGenes = ncol(datExpr0) 
nSamples = nrow(datExpr0) 
nSelect = 400 
# 为了重现性，设置随机数种子
set.seed(123) 
select = sample(nGenes, size = nSelect) 
selectTOM = dissTOM[select, select] 

selectTree = hclust(as.dist(selectTOM), method = "average") 
selectColors = moduleColors[select] 

plotDiss = selectTOM^7 
diag(plotDiss) = NA
library("gplots") 
pdf(file="8.Network heatmap plot_selected genes.pdf",width=9, height=9) 
mycol = colorpanel(250,'red','orange','lemonchiffon') 
TOMplot(plotDiss, selectTree, selectColors, col=mycol ,main = "Network heatmap plot, selected genes") 
dev.off()

pdf(file="9.Eigengene dendrogram and Eigengene adjacency heatmap.pdf", width=5, height=7.5) 
par(cex = 0.9) 
plotEigengeneNetworks(MEs, "", marDendro = c(0,4,1,2), marHeatmap = c(3,4,1,2), cex.lab = 0.8, xLabelsAngle= 90) 
dev.off()

pdf(file="Eigengene dendrogram.pdf",width=6, height=6) 
par(cex = 1.0) 
plotEigengeneNetworks(MEs, "Eigengene dendrogram", marDendro = c(0,4,2,0), plotHeatmaps = FALSE) 
dev.off()

pdf(file="Eigengene adjacency heatmap.pdf",width=6, height=6) 
par(cex = 1.0) 
plotEigengeneNetworks(MEs, "Eigengene adjacency heatmap", marHeatmap = c(3,4,2,2), plotDendrograms = FALSE, xLabelsAngle = 90) 
dev.off()
```

```{r}
# 计算模块与基因的相关性矩阵
if (corType=="pearsoon") {
  geneModuleMembership = as.data.frame(cor(datExpr0, MEs, use = "p"))
  MMPvalue = as.data.frame(corPvalueStudent(
             as.matrix(geneModuleMembership), nSamples))
} else {
  geneModuleMembershipA = bicorAndPvalue(datExpr0, MEs, robustY=robustY)
  geneModuleMembership = geneModuleMembershipA$bicor
  MMPvalue   = geneModuleMembershipA$p
}

if (corType=="pearsoon") {
  geneTraitCor = as.data.frame(cor(datExpr0, datTraits, use = "p"))
  geneTraitP = as.data.frame(corPvalueStudent(
             as.matrix(geneTraitCor), nSamples))
} else {
  geneTraitCorA = bicorAndPvalue(dataExpr, traitData, robustY=robustY)
  geneTraitCor = as.data.frame(geneTraitCorA$bicor)
  geneTraitP   = as.data.frame(geneTraitCorA$p)
}

# 最后把两个相关性矩阵联合起来,指定感兴趣模块进行分析
module = "grey"
pheno = "Cancer"
modNames = substring(colnames(MEs), 3)
# 获取关注的列
module_column = match(module, modNames)
pheno_column = match(pheno,colnames(datTraits))
# 获取模块内的基因
moduleGenes = moduleColors == module

sizeGrWindow(7, 7)
par(mfrow = c(1,1))
# 与性状高度相关的基因，也是与性状相关的模型的关键基因
verboseScatterplot(abs(geneModuleMembership[moduleGenes, module_column]),
                   abs(geneTraitCor[moduleGenes, pheno_column]),
                   xlab = paste("Module Membership in", module, "module"),
                   ylab = paste("Gene significance for", pheno),
                   main = paste("Module membership vs. gene significance\n"),
                   cex.main = 1.2, cex.lab = 1.2, cex.axis = 1.2, col = module)

Cancer <- as.data.frame(datTraits$Cancer)
names(Cancer) <- "Cancer"
modNames <- substring(names(MEs), 3)# 获得模块名

geneModuleMembership <- as.data.frame(cor(datExpr0, MEs, use="p"))
MPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples)) # 每个样本的相关性值的P值
names(geneModuleMembership) <- paste("MM", modNames, sep="")
names(MPvalue) <- paste("p.MM", modNames, sep="")


geneTraitSignificance <- as.data.frame(cor(datExpr0, datTraits, use="p"))
GPvalue <- as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples))

names(geneTraitSignificance) <- paste("GS.", names(datTraits), sep="")
names(GPvalue) <- paste("p.GS.", names(datTraits), sep="")

probes <- names(datExpr0)
a <- names(datExpr0)[moduleColors=="grey"] # 返回数据turquoise的基因ID

geneInfo <- data.frame(substanceBXH = probes,
                       GeneID = probes,
                       modulecolor = moduleColors,
                       geneTraitSignificance,GPvalue)

# 按照与Cancer的显著水平对模块进行排序
modOrder = order(-abs(cor(MEs, datTraits$Cancer, use = "p")));

# 添加模块成员的信息
for (mod in 1:ncol(geneModuleMembership)) {
    oldNames = names(geneInfo)
    geneInfo = data.frame(geneInfo, geneModuleMembership[, modOrder[mod]], 
                         MPvalue[, modOrder[mod]])
    names(geneInfo) = c(oldNames, paste("MM.", modNames[modOrder[mod]], sep=""),
                        paste("p.MM.", modNames[modOrder[mod]], sep=""))
}

# 重新排序基因信息
geneOrder = order(geneInfo$modulecolor, -abs(geneInfo$GS.Cancer));
geneInfo = geneInfo[geneOrder, ]

library(org.Mm.eg.db)
library(org.Hs.eg.db)

# 利用org.Hs.eg.db转换ENSEMBL->SYMBOL
X <- row.names(geneInfo)
Y <- select(org.Hs.eg.db,
                 keys = X,
                 columns = c('SYMBOL'),
                 keytype = "ENSEMBL")
geneInfo <- merge(geneInfo, Y, by.x = "GeneID", by.y = "ENSEMBL", all.x = T)
geneInfo <- geneInfo %>% relocate(SYMBOL, .after = 2)
# 输出为CSV格式
write.csv(geneInfo, file = "wgcna_geneInfo.csv")
```

# stringdb PPI
```{r}
GSE233242_normal_luminalA_deseq <- read.csv("D:/data/GSE233242_Breast cancer/Breast cancer/GSE233242_normal_luminalA_deseq.csv")

# 创建STRINGdb对象
string_db <- STRINGdb$new( version="11", species=9606, 
                           score_threshold=400, input_directory="")
# clusterProfiler将Gene Symbol转换为Entrez ID
gene <- GSE233242_normal_luminalA_deseq$SYMBOL %>% bitr(fromType = "SYMBOL", 
                      toType = "ENTREZID", 
                      OrgDb = "org.Hs.eg.db", 
                      drop = T)
data_mapped <- gene %>% string_db$map(my_data_frame_id_col_names = "ENTREZID", 
                removeUnmappedRows = TRUE)
string_db$plot_network( data_mapped$STRING_id[1:100] )
```

```{r}
hit<-data_mapped$STRING_id[1:100]
info <- string_db$get_interactions(hit)

# 转换stringID为Symbol，只取前两列和最后一列
links <- info %>%
  mutate(from = data_mapped[match(from, data_mapped$STRING_id), "SYMBOL"]) %>% 
  mutate(to = data_mapped[match(to, data_mapped$STRING_id), "SYMBOL"]) %>%  
  dplyr::select(from, to , last_col()) %>% 
  dplyr::rename(weight = combined_score)
# 节点数据
nodes <- links %>% { data.frame(gene = c(.$from, .$to)) } %>% distinct()
# 创建网络图
# 根据links和nodes创建
net <- igraph::graph_from_data_frame(d=links,vertices=nodes,directed = F)
# 添加一些参数信息用于后续绘图
# V和E是igraph包的函数，分别用于修改网络图的节点（nodes）和连线(links)
igraph::V(net)$deg <- igraph::degree(net) # 每个节点连接的节点数
igraph::V(net)$size <- igraph::degree(net)/5 
igraph::E(net)$width <- igraph::E(net)$weight/10

# 使用ggraph绘图
# ggraph是基于ggplot2的包，语法和常规ggplot2类似
ggraph(net,layout = "kk")+
  geom_edge_fan(aes(edge_width=width), color = "lightblue", show.legend = F)+
  geom_node_point(aes(size=size), color="orange", alpha=0.7)+
  geom_node_text(aes(filter=deg>5, label=name), size = 5, repel = T)+
  scale_edge_width(range = c(0.2,1))+
  scale_size_continuous(range = c(1,10) )+
  guides(size=F)+
  theme_graph()

ggraph(net,layout = "stress")+ #不同的地方
  geom_edge_fan(aes(edge_width=width), color = "lightblue", show.legend = F)+
  geom_node_point(aes(size=size), color="orange", alpha=0.7)+
  geom_node_text(aes(filter=deg>5, label=name), size = 5, repel = T)+
  scale_edge_width(range = c(0.2,1))+
  scale_size_continuous(range = c(1,10) )+
  guides(size=F)+
  theme_graph()

ggraph(net,layout = "linear", circular = TRUE)+
  geom_edge_fan(aes(edge_width=width), color = "lightblue", show.legend = F)+
  geom_node_point(aes(size=size), color="orange", alpha=0.7)+
  geom_node_text(aes(filter=deg>5, label=name), size = 5, repel = F)+
  scale_edge_width(range = c(0.2,1))+
  scale_size_continuous(range = c(1,10) )+
  guides(size=F)+
  theme_graph()

# 去除游离的互作关系
# 如果links数据框的一个link的from只出现过一次，同时to也只出现一次，则将其去除
links_2 <- links %>% mutate(from_c = count(., from)$n[match(from, count(., from)$from)]) %>%
  mutate(to_c = count(., to)$n[match(to, count(., to)$to)]) %>%
  filter(!(from_c == 1 & to_c == 1)) %>%
  dplyr::select(1,2,3)
# 新的节点数据
nodes_2 <- links_2 %>% { data.frame(gene = c(.$from, .$to)) } %>% distinct()
# 创建网络图
net_2 <- igraph::graph_from_data_frame(d=links_2,vertices=nodes_2,directed = F)
# 添加必要的参数
igraph::V(net_2)$deg <- igraph::degree(net_2)
igraph::V(net_2)$size <- igraph::degree(net_2)/5
igraph::E(net_2)$width <- igraph::E(net_2)$weight/10

ggraph(net_2,layout = "linear", circular = TRUE)+
  geom_edge_arc(aes(edge_width=width), color = "lightblue", show.legend = F)+
  geom_node_point(aes(size=size), color="orange", alpha=0.7)+
  geom_node_text(aes(filter=deg>5, label=name), size = 5, repel = F)+
  scale_edge_width(range = c(0.2,1))+
  scale_size_continuous(range = c(1,10) )+
  guides(size=F)+
  theme_graph()

links_2 %>% tidygraph::as_tbl_graph() %>%
  ggraph(layout = "kk")+
  geom_edge_fan(color = "grey")+
  geom_node_point(size=5, color="blue", alpha=0.8)+
  geom_node_text(aes(label=name), repel = T)+
  theme_void()

links_2 %>% tidygraph::as_tbl_graph() %>%
  ggraph(layout = "stress")+
  geom_edge_fan(color = "grey")+
  geom_node_point(size=5, color="blue", alpha=0.8)+
  geom_node_text(aes(label=name), repel = T)+
  theme_void()

links_2 %>% tidygraph::as_tbl_graph() %>%
    ggraph(layout = "linear", circular = TRUE)+
    geom_edge_fan(color = "grey")+
    geom_node_point(size=5, color="blue", alpha=0.8)+
    geom_node_text(aes(label=name), repel = T)+
    theme_void()


```


